# Project Description

This description was generated by AI based on the most recent version, update this description as changes are made!

## Purpose

* Experiments show how attaching previous model answers as “sources” can magnify small hallucinations, highlighting the risks of blindly trusting iterative AI summaries.
* Authenticated users run side-by-side chats with multiple OpenRouter-hosted LLMs while switching which prior answer is recycled into the next prompt.
* Visitors without accounts still see published example chats, so the educational angle remains accessible to everyone.
* Chats are ephemeral by default; users must consciously save or publish them, reinforcing that careless reuse leads to information loss.

## System Architecture

* `app.py` (line 1) instantiates a FastAPI app that mounts every route from app/routes.py, acting as the single backend entry point.
* Server-side HTML rendering uses Jinja templates (`app/routes.py` (lines 223-254)) for /, /examples, and /saved-chats, combining user context with the statically defined `models_list` helper (`app/or_models_list.py` (line 1)).
* Persistence relies on SQLAlchemy models in app/model_schema/models.py, with SQLite as the default DB (`app/routes.py` (lines 22-33)); swap `DATABASE_URL` to point to Postgres/MySQL in production.
* Pydantic schemas in `app/model_schema/schema.py` strictly validate requests/responses so both the frontend and API share one contract.

## Data Model

* Users, chats, messages, highlights, and per-day usage counters live in dedicated tables (`app/model_schema/models.py` (lines 20-148)), ensuring relational integrity between a user’s saved history and public posts.
* `RateLimiting` keeps a unique record per user per day to track both tokens and message counts (`app/model_schema/models.py` (lines 45-64)).
* Chat rows capture publication metadata such as slug, anonymous flag, likes, and timestamps, while ChatMessage + Highlight store the conversational timeline plus user annotations.
* Corresponding Pydantic models (`app/model_schema/schema.py` (lines 45-127)) mirror the ORM structure, enabling .model_validate() round‑trips straight from SQLAlchemy query results.

## Authentication & Access

* `/auth/signup`, `/auth/token`, and `/auth/verify` (`app/routes.py` (lines 166-218)) implement the lifecycle: create account, verify email via code entry, then obtain a JWT via the standard OAuth2 password flow.
* Passwords are hashed with Passlib’s bcrypt context, and email verification codes are persisted with expiration and “used” flags for auditability (`app/routes.py` (lines 69-80), `app/model_schema/models.py` (lines 66-79)).
* OAuth2PasswordBearer protects every API route that mutates state, while get_current_user_optional allows read paths to render different UI if a bearer token is present (`app/routes.py` (lines 126-160)).
* JWT payloads carry both `sub` (user id) and `email`, simplifying downstream authorization decisions.

## Chat Lifecycle & APIs

* `POST /api/v1/chat/submit` (`app/routes.py` (lines 260-288)) validates the requested model, stitches user prompt + selected source excerpts, and is the hook for calling OpenRouter (token accounting happens once the provider returns usage stats).
* `POST /api/v1/chats/save` (`app/routes.py` (lines 291-342)) persists an entire chat history, generates a unique slug via slugify/unique_slug, and optionally flags the chat as public if publish query param is set.
* `PUT /api/v1/chats/publish-from-saved` (`app/routes.py` (lines 344-365)) promotes an existing private chat to the public gallery after ownership checks, letting users retitle or anonymize before publication.
* `GET /api/v1/chats/saved/{slug}` (`app/routes.py` (lines 368-388)) loads a full conversation (messages + highlights via joinedload) so both the owner and public visitors can inspect the narrative thread.

## Rate Limiting & Quotas

* `check_rate_limits` and `update_rate_limits` (`app/routes.py` (lines 96-143)) share a helper to ensure a daily usage row exists; the former raises if a request would exceed the configured ceilings while the latter records the actual deltas once token stats are known.
* Limits default to 50 000 tokens and 100 messages per day (`app/routes.py` (lines 25-27)) but are environment-driven for easy tuning.
* The chat-submit flow first calls `check_rate_limits`, then records consumption via `update_rate_limits` once the OpenRouter API provides actual token usage numbers.
* Because limits are per-user, guests must sign up to exercise the chat interface; the `/examples` page is the only unauthenticated experience.

## Frontend Contract

* The browser keeps a `chats` array shaped exactly like `docs/example_schema.js` (lines 1-51), mirroring `ChatHistoryPayload` so saving/publishing is just a POST of the in-memory structure.
* `role` differentiates human (0) vs. model (1) turns, `highlights` capture user-curated spans, and `pretty_name` is a friendly alias for the OpenRouter `model_id`.
* Until a user explicitly saves, all chats stay client-side—refreshing clears state, reinforcing the “sandbox” intent.
* When rendering templates (e.g., `/` route), the backend injects `models_list` so the frontend can populate dropdowns without another network call.

## Operational Notes

* Email verification currently assumes an external mailer; `save_verification_token` just returns the token (`app/routes.py` (lines 69-80)), so add a delivery layer before deploying.
* Actual OpenRouter interaction is stubbed (`app/routes.py` (lines 276-287)); plug in your preferred HTTP client there and set tokens_used from the provider’s response.
* Static templates (`app/templates/index.html`) are placeholders; expand them into the real UI or mount a SPA build using the same routes.
* Rate limiting logic uses DB transactions with `with_for_update`; if you migrate to a fully asynchronous stack, switch to an async-friendly ORM/session pattern.
